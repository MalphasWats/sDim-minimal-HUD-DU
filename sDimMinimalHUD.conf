name: sDimMinimalHUDm

slots:
    core:
        class: CoreUnit
    antigrav:
        class: AntiGravityGeneratorUnit
    warpdrive:
        class: WarpDriveUnit
    atmofueltank:
        class: AtmoFuelContainer
        select: manual
    spacefueltank:
        class: SpaceFuelContainer
        select: manual
    rocketfueltank:
        class: RocketFuelContainer
        select: manual
    gyro:
        class: GyroUnit
    weapon:
        class: WeaponUnit
        select: manual
    atmo_radar:
        class: RadarPVPAtmospheric
        select: all
    space_radar:
        class: RadarPVPSpace
        select: manual
    databank:
        class: DataBankUnit
    screen:
        class: ScreenUnit
        select: manual
    forcefields:
        class: ManualSwitchUnit
        select: manual
    telemeter:
        class: TelemeterUnit
        select: manual
    emitter:
        class: EmitterUnit
        select: manual

handlers:
    library:
        onStart:
          lua: |

            hudTemplate = [[
                <head>
                  <style>
                    body {margin: 0}
                    svg {position:absolute; top:0; left:0}
                    .outline {stroke:#b6dfed; stroke-width:2px; fill:#000000; fill-opacity:0.6;}

                    .line { fill:none; stroke:#b6dfed; stroke-width:3px; }
                    .mediumLine {fill:none; stroke:#b6dfed; stroke-width:2px; }
                    .thinLine { fill:none; stroke:#b6dfed; stroke-width:1px; }

                    .throttleMaxLine { fill:#ffffff66; stroke:#ffffff66; stroke-width:1px;}
                    .throttleLine { fill:#ff7e00; stroke:#ff7e00; stroke-width:1px;}

                    .fuelLine { fill:#aa0016; stroke:#aa001666; stroke-width:1px;}
                    .atmoFuelLine { fill:#4c8ba7; stroke:#4c8ba7; stroke-width:1px;}
                    .spaceFuelLine { fill:#fcba12; stroke:#fcba12; stroke-width:1px;}
                    .rocketFuelLine { fill:#323C73; stroke:#323C73; stroke-width:1px;}

                    .on {fill:#4c8ba7;}
                    .off {fill:none;}

                    text {fill:#b6dfed; stroke:none; font-size:100%%; font-family:sans-serif;}
                    .smallText { font-size:90%% }
                    .largeText { font-size:160%% }
                    .error {fill:#aa0016;}
                    .ok {fill:#00ff00;}
                    .damaged {fill:#ff7e00; stroke:#b6dfed; stroke-width:1px;}
                    .destroyed {fill:#aa0016; stroke:#b6dfed; stroke-width:1px;}
                  </style>
                </head>
                <body>

                <svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg" width="1920" height="1080">

                  <g class="outline">
                    <path style="stroke:none;" d="M 585,1080 589,1074 585,1063 615,1024 625,1026 645,998 645,988 1275,988 1275,998 1295,1026 1305,1024 1335,1063 1331,1074 1335,1080 Z" />
                    <path d="M 585,1080 589,1074 585,1063 615,1024 625,1026 645,998 645,988 577,992 457,1048 207,1060 195,1080" />

                    <path d="m 565,1070 6,-1" />
                    <path d="m 605,1012 4,8" />

                    <path d="M 1335,1080 1331,1074 1335,1063 1305,1024 1295,1026 1275,998 1275,988 1343,992 1463,1048 1713,1060 1725,1080" />
                    <path d="m 1355,1070 -6,-1" />
                    <path d="m 1315,1012 -4,8" />
                  </g>
                  <g class="thinLine" transform="translate(670, 1045)">
                    <text x="-10" y="20" text-anchor="end">Throttle</text>
                    <rect class="throttleMaxLine" x="0" y="11" width="200" height="10" />
                    <rect class="throttleLine" x="%d" y="11" width="%d" height="10" />

                    <line class="thinLine" x1="0" y1="2" x2="0" y2="10"/>
                    <line class="thinLine" x1="100" y1="2" x2="100" y2="10"/>
                    <line class="thinLine" x1="200" y1="2" x2="200" y2="10"/>

                    <line class="thinLine" x1="20" y1="5" x2="20" y2="10"/>
                    <line class="thinLine" x1="40" y1="5" x2="40" y2="10"/>
                    <line class="thinLine" x1="60" y1="5" x2="60" y2="10"/>
                    <line class="thinLine" x1="80" y1="5" x2="80" y2="10"/>

                    <line class="thinLine" x1="120" y1="5" x2="120" y2="10"/>
                    <line class="thinLine" x1="140" y1="5" x2="140" y2="10"/>
                    <line class="thinLine" x1="160" y1="5" x2="160" y2="10"/>
                    <line class="thinLine" x1="180" y1="5" x2="180" y2="10"/>
                  </g>

                  <g class="thinLine" transform="translate(930, 1045)">
                    <text x="-10" y="20" text-anchor="end">Fuel</text>
                    %s
                  </g>

                  <g class="thinLine smallText" transform="translate(1045, 1040)">
                    <text x="50" y="14" text-anchor="end">Brakes</text>
                    <text x="50" y="32" text-anchor="end">Gear</text>

                    <path class="%s" d="M 6,0 H 18 L 20,6 14,14 H 2 L 0,10 Z" transform="translate(80, 2) scale(-1, 1)"/>
                    <path class="%s" d="M 6,0 H 18 L 20,6 14,14 H 2 L 0,10 Z" transform="translate(80, 2)"/>
                    <path class="%s" d="M 6,0 H 18 L 20,6 14,14 H 2 L 0,10 Z" transform="translate(80, 32) scale(1, -1)"/>
                    <path class="%s" d="M 6,0 H 18 L 20,6 14,14 H 2 L 0,10 Z" transform="translate(80, 32) scale(-1, -1)"/>
                    <text style="font-size:9pt; fill:#000000" x="86" y="12" text-anchor="start">%s</text>
                    <text x="110" y="14" text-anchor="start">Hold</text>
                    <text x="110" y="32" text-anchor="start">F. Ass.</text>

                    <line class="thinLine" x1="165" y1="0" x2="165" y2="34"/>

                    <text x="220" y="12" text-anchor="end">Mass</text>
                    <text x="220" y="30" text-anchor="end">B. Dist.</text>

                    <text x="225" y="12" text-anchor="start">%.1f %s</text>
                    <text x="225" y="30" text-anchor="start">%.2f %s</text>
                  </g>

                  <g class="smallText" transform="translate(650, 990)">
                    <text x="40" y="14" text-anchor="end">Pitch:</text>
                    <text x="40" y="28" text-anchor="end">Roll:</text>
                    <text x="40" y="42" text-anchor="end">Yaw:</text>
                    <text x="85" y="14" text-anchor="end">%.1f°</text>
                    <text x="85" y="28" text-anchor="end">%.1f°</text>
                    <text x="85" y="42" text-anchor="end">%.1f°</text>

                    %s

                    <text x="400" y="14" text-anchor="end">Planet:</text>
                    <text x="400" y="28" text-anchor="end">Apoap:</text>
                    <text x="400" y="42" text-anchor="end">Periap:</text>
                    <text x="405" y="14" text-anchor="start">%s</text>
                    <text x="405" y="28" text-anchor="start">%.0f m</text>
                    <text x="405" y="42" text-anchor="start">%.0f m</text>

                    <text x="530" y="14" text-anchor="end">%s</text>
                    <text x="530" y="28" text-anchor="end">%s</text>
                    <text x="530" y="42" text-anchor="end">%s</text>
                    <text x="535" y="14" text-anchor="start">%s</text>
                    <text x="535" y="28" text-anchor="start">%s</text>
                    <text x="535" y="42" text-anchor="start">%s</text>
                  </g>

                  <g class="smallText" transform="translate(460, 1050)">
                    <text x="120" y="0" text-anchor="end">DMG: %d / %d</text>
                    %s %s
                  </g>

                  <g class="smallText" transform="translate(1380, 1050)">
                    <text x="0" y="0" text-anchor="end">CCS:</text>
                    <text x="5" y="0" text-anchor="start">%.0f %%</text>

                    %s
                  </g>

                  <text style="font-size:110%%" x="1460" y="80" text-anchor="end">%s</text>
                  %s

                  %s
                </svg>

                </body>]]

                fuelTankTemplate = [[<rect class="fuelLine" x="0" y="%d" width="100" height="%d" />
                <rect class="%s" x="0" y="%d" width="%d" height="%d" />]]

                warpDriveTemplate = [[<text x="250" y="14" text-anchor="end">Warp:</text>
                <text x="250" y="28" text-anchor="end">Dist:</text>
                <text x="250" y="42" text-anchor="end">Cells:</text>
                <text x="255" y="14" text-anchor="start">%s</text>
                <text x="255" y="28" text-anchor="start">%.1f su</text>
                <text x="255" y="42" text-anchor="start">%s</text>

                <rect class="thinLine" x="325" y="22" width="18" height="18" />
                <rect class="%s" x="327" y="24" width="14" height="14" />]]

                shieldDataTemplate = [[<text x="0" y="14" text-anchor="end">Shield:</text>
                <text x="5" y="14" text-anchor="start">%.0f%%</text>

                <text x="60" y="14" text-anchor="start">AM: %.0f%%</text>
                <text x="125" y="14" text-anchor="start">EM: %.0f%%</text>
                <text x="190" y="14" text-anchor="start">KI: %.0f%%</text>
                <text x="245" y="14" text-anchor="start">TH: %.0f%%</text>]]

                guidelineTemplate = [[<line class="thinLine " x1="1764.5" y1="30" x2="1764.5" y2="280"/>]]

                keypadTemplate = [[<g class="outline largeText" transform="translate(%d, %d)">
                  <rect x="0" y="0" width="130" height="220" />
                  <rect x="10" y="10" width="110" height="30" /><text x="115" y="34" text-anchor="end">%s</text>
                  <rect x="10" y="60" width="30" height="30" /><text x="25" y="84" text-anchor="middle">1</text>
                  <rect x="50" y="60" width="30" height="30" /><text x="65" y="84" text-anchor="middle">2</text>
                  <rect x="90" y="60" width="30" height="30" /><text x="105" y="84" text-anchor="middle">3</text>
                  <rect x="10" y="100" width="30" height="30" /><text x="25" y="124" text-anchor="middle">4</text>
                  <rect x="50" y="100" width="30" height="30" /><text x="65" y="124" text-anchor="middle">5</text>
                  <rect x="90" y="100" width="30" height="30" /><text x="105" y="124" text-anchor="middle">6</text>
                  <rect x="10" y="140" width="30" height="30" /><text x="25" y="164" text-anchor="middle">7</text>
                  <rect x="50" y="140" width="30" height="30" /><text x="65" y="164" text-anchor="middle">8</text>
                  <rect x="90" y="140" width="30" height="30" /><text x="105" y="164" text-anchor="middle">9</text>
                  <rect x="10" y="180" width="30" height="30" /><text x="25" y="204" text-anchor="middle">E</text>
                  <rect x="50" y="180" width="30" height="30" /><text x="65" y="204" text-anchor="middle">0</text>
                  <rect x="90" y="180" width="30" height="30" /><text x="105" y="204" text-anchor="middle">D</text>

                  <circle cx="%.0f" cy="%.0f" r="5" class="ok"/>
                </g>]]

                damagedItemTemplate = [[<circle cx="%d" cy="%d" r="4" class="%s" /><text x="%d" y="%d" text-anchor="end">%s</text>]]

                -- Rocket to Space engine transition patch.
                local realGetMaxKP = core.getMaxKinematicsParametersAlongAxis
                core.getMaxKinematicsParametersAlongAxis = function (...)
                  local result = realGetMaxKP(...)
                  if result[1] < 1 then result[1] = result[3] end
                  if result[2] < 1 then result[2] = result[4] end
                  return result
                end

                function getPitch(gravityDirection, forward, right)
                  local horizontalForward = gravityDirection:cross(right):normalize_inplace()
                  local pitch = math.acos(utils.clamp(horizontalForward:dot(-forward), -1, 1)) * constants.rad2deg
                  if horizontalForward:cross(-forward):dot(right) < 0 then pitch = -pitch end
                  return pitch
                end

                function getRelativePitch(velocity)
                  local pitch = -math.deg(math.atan(velocity.y, velocity.z)) + 180
                  -- This is 0-360 where 0 is straight up
                  pitch = pitch - 90
                  -- So now 0 is straight, but we can now get angles up to 420
                  if pitch < 0 then
                     pitch = 360 + pitch
                  end
                  -- Now, if it's greater than 180, say 190, make it go to like -170
                  if pitch > 180 then
                     pitch = -180 + (pitch-180)
                  end
                  -- And it's backwards.
                  return -pitch
                end

                function vMouseReset()
                  vMouse = {
                    x = 0,
                    y = 0,
                    maxX = 0,
                    maxY = 0,
                    drawHandler = false,
                    clickHandler = false,
                    affirmativeHandler = false,
                    negativeHandler = false
                  }
                end

                function showSingularityKeypad()
                  vMouse.x = 0
                  vMouse.y = 0
                  vMouse.maxX = 130
                  vMouse.maxY = 220
                  vMouse.drawHandler = drawKeypad
                  vMouse.clickHandler = keypadClickHandler
                  vMouse.affirmativeHandler = setSingularityFromKeypad
                  vMouse.negativeHandler = cancelSingularityKeypad
                  vMouse.uiString = ""
                end

                function drawKeypad()
                  local keypadValueString = string.format("%d", keypadValue)
                  vMouse.uiString = string.format(keypadTemplate, 1200, 750, keypadValueString, vMouse.x, vMouse.y)
                end

                function setSingularityFromKeypad()
                  antigrav.setBaseAltitude(keypadValue)
                  cancelSingularityKeypad()
                end

                function cancelSingularityKeypad()
                  vMouse.drawHandler = false
                  vMouse.uiString = ""
                  vMouse.affirmativeHandler = false
                  vMouse.negativeHandler = false
                  keypadValue = 0
                end

                function keypadClickHandler()
                  local btn = math.floor((vMouse.x - 10) / 40) + ( math.floor((vMouse.y - 60) / 40) * 3) + 1
                  if btn > 0 and btn < 10 then
                    keypadValue = (keypadValue * 10) + btn
                  elseif btn == 10 then
                    vMouse.affirmativeHandler()
                  elseif btn == 11 then
                    keypadValue = keypadValue * 10
                  elseif btn == 12 then
                    keypadValue = math.floor(keypadValue / 10)
                  else
                    vMouse.negativeHandler()
                  end
                end

                function updateDMG()
                  local elementIDList = core.getElementIdList()

                  local elements = ""

                  local damaged_count = 0
                  local destroyed_count = 0

                  local damaged_elements = ""
                  local destroyed_elements = ""

                  for _,id in pairs(elementIDList) do
                      local max_hp = core.getElementMaxHitPointsById(id)
                      local curr_hp = core.getElementHitPointsById(id)
                      local name = core.getElementNameById(id)

                      if curr_hp == 0 then
                          destroyed_count = destroyed_count + 1
                          destroyed_elements = destroyed_elements .. string.format(damagedItemTemplate, 0, -(4+destroyed_count*14), "destroyed", -20, -(0+destroyed_count*14), name)
                      elseif curr_hp < max_hp then
                          damaged_count = damaged_count + 1
                          damaged_elements = damaged_elements .. string.format(damagedItemTemplate, -180, -(4+damaged_count*14), "damaged", -200, -(0+damaged_count*14), name)
                      end
                  end

                  damageReport.damaged = damaged_count
                  damageReport.destroyed = destroyed_count
                  damageReport.damaged_elements = damaged_elements
                  damageReport.destroyed_elements = destroyed_elements
                end

                function calculateBrakingDistance()
                  
                  local speed = vec3.new(construct.getWorldVelocity()):len()
                  local mass = construct.getMass()
                  local maxBrakingForce = -construct.getMaxBrake()
                
                  local a = maxBrakingForce / mass
                  local t = math.abs(speed / a)
                  brakingDistance = (speed*t + a * t * t / 2) / 1000
                  brakingDistanceUnit = "km"
                  if brakingDistance > 100 then
                    brakingDistance = brakingDistance / 200
                    brakingDistanceUnit = "su"
                  end
                end

                function getOrbitalParameters()

                  local position = construct.getWorldPosition()
                  local pos = vec3(position)
                  local planet

                  local minDistance2
                  for _, params in pairs(atlas[0]) do
                      local bcenter = {
                          x = params.center[1],
                          y = params.center[2],
                          z = params.center[3]
                      }
                      local distance2 = (bcenter - pos):len2()
                      if (not planet or distance2 < minDistance2) and params.name[1] ~= "Space" then -- Never return space.
                          planet = params
                          minDistance2 = distance2
                      end
                  end

                  planetName = planet.name[1]

                  local velocity = construct.getWorldVelocity()
                  local v = vec3(velocity)

                  local center = vec3(planet.center)

                  planetAlt = (pos - center):len() - planet.radius - planet.surfaceAverageAltitude
                  atmosEdge = (pos - center):len() - planet.radius - planet.atmosphereThickness
                  if atmosEdge > 10000 then
                    atmosEdge = atmosEdge / 1000
                    atmosEdgeUnits = "km"
                    if atmosEdge > 100 then
                      atmosEdge = atmosEdge / 200
                      atmosEdgeUnits = "su"
                    end
                  end


                  local r = pos - center
                  local v2 = v:len2()
                  local d = r:len()
                  local mu = planet.GM
                  local e = ((v2 - mu / d) * r - r:dot(v) * v) / mu
                  local a = mu / (2 * mu / d - v2)
                  local ecc = e:len()

                  local pd = a * (1 - ecc)
                  local ad = a * (1 + ecc)

                  periapsis = pd - planet.radius
                  apoapsis = ad - planet.radius
                  --if periapsis < 0 or periapsis > 99999 then periapsis = 0 end
                  --if apoapsis < 0 or apoapsis > 99999 then apoapsis = 0 end
                end
    unit:
        onStart:
          lua: |
                pitchInput = 0
                rollInput = 0
                yawInput = 0
                brakeInput = 0

                brakeLock = false

                targetAltitude = 0
                targetPitch = 0

                holdMode = 1
                flightAssist = false
                alignmentTarget = false
                collisionAvoidance = false

                boosting = false

                keypadValue = 0
                keypadValueString = ""

                vMouse = {}
                vMouseReset()

                Nav = Navigator.new(system, core, unit)
                Nav.axisCommandManager:setupCustomTargetSpeedRanges(axisCommandId.longitudinal, {1000, 5000, 10000, 20000, 30000})
                -- Set R & T to 5% throttle, mousewheel still 10%
                Nav.axisCommandManager.axisCommands[axisCommandId.longitudinal].throttleAtomicStepValue  = 0.01
                Nav.axisCommandManager.axisCommands[axisCommandId.longitudinal].throttleMouseStepScale  =  10

                Nav.axisCommandManager:setTargetGroundAltitude(0)

                unit.hideWidget()
                system.showHelper(0)

                construct.setDockingMode(2) -- Should dock with all owned

                if Nav.control.isRemoteControlled() == 1 then
                  system.freeze(1)
                end

                -- landing gear
                -- make sure every gears are synchonized with the first
                gearExtended = (unit.isAnyLandingGearDeployed() == 1) -- make sure it's a lua boolean
                if gearExtended then
                    unit.deployLandingGears()
                    Nav.axisCommandManager:setTargetGroundAltitude(0)
                else
                    unit.retractLandingGears()
                    Nav.axisCommandManager:setTargetGroundAltitude(100)
                end

                atmoTanksMax = {}
                atmoTanksCurrent = {}

                rocketTanksMax = {}
                rocketTanksCurrent = {}

                spaceTanksMax = {}
                spaceTanksCurrent = {}

                fuelTankCount = atmofueltank_size + rocketfueltank_size + spacefueltank_size
                fuelTankDrawHeight = math.floor(22 / fuelTankCount)
                if fuelTankDrawHeight < 3 then fuelTankDrawHeight = 3 end
                local totalTankDrawHeight = fuelTankDrawHeight * fuelTankCount
                fuelTankTopOffset = 22 - totalTankDrawHeight
                if fuelTankTopOffset < 0 then fuelTankTopOffset = 0 end

                for tank=1,atmofueltank_size do
                  atmoTanksMax[tank] = math.floor(atmofueltank[tank].getMaxVolume())
                  atmoTanksCurrent[tank] = math.floor(atmofueltank[tank].getItemsVolume())
                end

                for tank=1,rocketfueltank_size do
                  rocketTanksMax[tank] = math.floor(rocketfueltank[tank].getMaxVolume())
                  rocketTanksCurrent[tank] = math.floor(rocketfueltank[tank].getItemsVolume())
                end

                for tank=1,spacefueltank_size do
                  spaceTanksMax[tank] = math.floor(spacefueltank[tank].getMaxVolume())
                  spaceTanksCurrent[tank] = math.floor(spacefueltank[tank].getItemsVolume())
                end

                unit.setTimer("updateTanks", 1) -- one second

                calculateBrakingDistance()
                unit.setTimer("updateBraking", 1) -- 30 seconds

                periapsis = 0
                apoapsis = 0
                planetName = "None"
                planetAlt = 0
                atmosEdge = 0
                atmosEdgeUnits = "m"

                getOrbitalParameters()
                unit.setTimer("updateOrbitParams", 1) -- 1 seconds

                damageReport = {damaged = 0, destroyed = 0, damaged_elements="", destroyed_elements=""}
                updateDMG()
                unit.setTimer("updateDMGReport",  10)
        onStop:
            lua: |
                

        tick:
            args: ["updateTanks"]
            lua: |
              for tank=1,atmofueltank_size do
                atmoTanksCurrent[tank] = math.floor(atmofueltank[tank].getItemsVolume())
              end
  
              for tank=1,rocketfueltank_size do
                rocketTanksCurrent[tank] = math.floor(rocketfueltank[tank].getItemsVolume())
              end
  
              for tank=1,spacefueltank_size do
                spaceTanksCurrent[tank] = math.floor(spacefueltank[tank].getItemsVolume())
              end

        tick:
            args: ["updateBraking"]
            lua: |
              calculateBrakingDistance()

        tick:
            args: ["updateOrbitParams"]
            lua: |
              getOrbitalParameters()

        tick:
            args: ["updateDMGReport"]
            lua: |
              updateDMG()

    system:
        onStart:
            lua: |
              atlas = require('atlas')
              system.setScreen('HUD Error')
              system.showScreen(1)
        onFlush:
            lua: |
                -- constants: use 'myvar = defaultValue --export: description' to expose the variable in context menu

                local pitchSpeedFactor = 0.8 --export: This factor will increase/decrease the player input along the pitch axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01
                local yawSpeedFactor =  1 --export: This factor will increase/decrease the player input along the yaw axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01
                local rollSpeedFactor = 1.5 --export: This factor will increase/decrease the player input along the roll axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01

                local brakeSpeedFactor = 3 --export: When braking, this factor will increase the brake force by brakeSpeedFactor * velocity<br>Valid values: Superior or equal to 0.01
                local brakeFlatFactor = 1 --export: When braking, this factor will increase the brake force by a flat brakeFlatFactor * velocity direction><br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01

                local autoRoll = false --export: [Only in atmosphere]<br>When the pilot stops rolling,  flight model will try to get back to horizontal (no roll)
                local autoRollFactor = 2 --export: [Only in atmosphere]<br>When autoRoll is engaged, this factor will increase to strength of the roll back to 0<br>Valid values: Superior or equal to 0.01

                local turnAssist = true --export: [Only in atmosphere]<br>When the pilot is rolling, the flight model will try to add yaw and pitch to make the construct turn better<br>The flight model will start by adding more yaw the more horizontal the construct is and more pitch the more vertical it is
                local turnAssistFactor = 2 --export: [Only in atmosphere]<br>This factor will increase/decrease the turnAssist effect<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01

                local torqueFactor = 2 -- Force factor applied to reach rotationSpeed<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01

                -- validate params
                pitchSpeedFactor = math.max(pitchSpeedFactor, 0.01)
                yawSpeedFactor = math.max(yawSpeedFactor, 0.01)
                rollSpeedFactor = math.max(rollSpeedFactor, 0.01)
                torqueFactor = math.max(torqueFactor, 0.01)
                brakeSpeedFactor = math.max(brakeSpeedFactor, 0.01)
                brakeFlatFactor = math.max(brakeFlatFactor, 0.01)
                autoRollFactor = math.max(autoRollFactor, 0.01)
                turnAssistFactor = math.max(turnAssistFactor, 0.01)

                -- Axis
                local worldVertical = vec3(core.getWorldVertical()) -- along gravity
                local constructUp = vec3(construct.getWorldOrientationUp())
                local constructForward = vec3(construct.getWorldOrientationForward())
                local constructRight = vec3(construct.getWorldOrientationRight())
                local constructVelocity = vec3(construct.getWorldVelocity())
                local constructVelocityDir = vec3(construct.getWorldVelocity()):normalize()
                local currentRollDeg = getRoll(worldVertical, constructForward, constructRight)
                local currentRollDegAbs = math.abs(currentRollDeg)
                local currentRollDegSign = utils.sign(currentRollDeg)

                if (brakeLock) then
                  brakeInput = 1
                end

                if holdMode>1 and unit.getAtmosphereDensity() > 0 then

                  local roll = getRoll(worldVertical, constructForward, constructRight)
                  local pitch = getPitch(worldVertical, constructForward, constructRight)
                  local targetRoll = 0

                  if holdMode == 3 then
                    local altitude = core.getAltitude()
                    local velMag = vec3(constructVelocity):len()

                    local altDiff = targetAltitude - altitude
                    local MaxPitch = 20

                    local minmax = 500 + velMag
                    targetPitch = (utils.smoothstep(altDiff, -minmax, minmax) - 0.5)*2*MaxPitch
                  end

                  if (rollPID == nil) then
                      rollPID = pid.new(6 * 0.01, 0, 6 * 0.02)
                  end
                  rollPID:inject(targetRoll - roll)
                  rollInput = rollPID:get()

                  if (pitchPID == nil) then
                    pitchPID = pid.new(8 * 0.01, 0, 8 * 0.01)
                  end
                  pitchPID:inject(targetPitch - pitch)
                  pitchInput = pitchPID:get()
                end

                -- final inputs
                local finalPitchInput = pitchInput + system.getControlDeviceForwardInput()
                local finalRollInput = rollInput + system.getControlDeviceYawInput()
                local finalYawInput = yawInput - system.getControlDeviceLeftRightInput()
                local finalBrakeInput = brakeInput

                -- Rotation
                local constructAngularVelocity = vec3(construct.getWorldAngularVelocity())
                local targetAngularVelocity = finalPitchInput * pitchSpeedFactor * constructRight
                                                + finalRollInput * rollSpeedFactor * constructForward
                                                + finalYawInput * yawSpeedFactor * constructUp

                -- In atmosphere?
                if worldVertical:len() > 0.01 and unit.getAtmosphereDensity() > 0.0 then
                    local autoRollRollThreshold = 1.0
                    -- autoRoll on AND currentRollDeg is big enough AND player is not rolling
                    if autoRoll == true and currentRollDegAbs > autoRollRollThreshold and finalRollInput == 0 then
                        local targetRollDeg = utils.clamp(0,currentRollDegAbs-30, currentRollDegAbs+30);  -- we go back to 0 within a certain limit
                        if (rollPID == nil) then
                            rollPID = pid.new(autoRollFactor * 0.01, 0, autoRollFactor * 0.1) -- magic number tweaked to have a default factor in the 1-10 range
                        end
                        rollPID:inject(targetRollDeg - currentRollDeg)
                        local autoRollInput = rollPID:get()

                        targetAngularVelocity = targetAngularVelocity + autoRollInput * constructForward
                    end
                    local turnAssistRollThreshold = 20.0
                    -- turnAssist AND currentRollDeg is big enough AND player is not pitching or yawing
                    if turnAssist == true and currentRollDegAbs > turnAssistRollThreshold and finalPitchInput == 0 and finalYawInput == 0 then
                        local rollToPitchFactor = turnAssistFactor * 0.1 -- magic number tweaked to have a default factor in the 1-10 range
                        local rollToYawFactor = turnAssistFactor * 0.025 -- magic number tweaked to have a default factor in the 1-10 range

                        -- rescale (turnAssistRollThreshold -> 180) to (0 -> 180)
                        local rescaleRollDegAbs = ((currentRollDegAbs - turnAssistRollThreshold) / (180 - turnAssistRollThreshold)) * 180
                        local rollVerticalRatio = 0
                        if rescaleRollDegAbs < 90 then
                            rollVerticalRatio = rescaleRollDegAbs / 90
                        elseif rescaleRollDegAbs < 180 then
                            rollVerticalRatio = (180 - rescaleRollDegAbs) / 90
                        end

                        rollVerticalRatio = rollVerticalRatio * rollVerticalRatio

                        local turnAssistYawInput = - currentRollDegSign * rollToYawFactor * (1.0 - rollVerticalRatio)
                        local turnAssistPitchInput = rollToPitchFactor * rollVerticalRatio

                        targetAngularVelocity = targetAngularVelocity
                                            + turnAssistPitchInput * constructRight
                                            + turnAssistYawInput * constructUp
                    end
                end

                -- Engine commands
                local keepCollinearity = 1 -- for easier reading
                local dontKeepCollinearity = 0 -- for easier reading
                local tolerancePercentToSkipOtherPriorities = 1 -- if we are within this tolerance (in%), we don't go to the next priorities

                -- Rotation
                local angularAcceleration = torqueFactor * (targetAngularVelocity - constructAngularVelocity)
                local airAcceleration = vec3(construct.getWorldAirFrictionAngularAcceleration())
                angularAcceleration = angularAcceleration - airAcceleration -- Try to compensate air friction
                Nav:setEngineTorqueCommand('torque', angularAcceleration, keepCollinearity, 'airfoil', '', '', tolerancePercentToSkipOtherPriorities)

                -- Brakes
                local brakeAcceleration = -finalBrakeInput * (brakeSpeedFactor * constructVelocity + brakeFlatFactor * constructVelocityDir)
                Nav:setEngineForceCommand('brake', brakeAcceleration)

                -- AutoNavigation regroups all the axis command by 'TargetSpeed'
                local autoNavigationEngineTags = ''
                local autoNavigationAcceleration = vec3()
                local autoNavigationUseBrake = false

                -- Longitudinal Translation
                local longitudinalEngineTags = 'thrust analog longitudinal'
                local longitudinalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)
                if (longitudinalCommandType == axisCommandType.byThrottle) then
                    local longitudinalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromThrottle(longitudinalEngineTags,axisCommandId.longitudinal)
                    Nav:setEngineForceCommand(longitudinalEngineTags, longitudinalAcceleration, keepCollinearity)
                elseif  (longitudinalCommandType == axisCommandType.byTargetSpeed) then
                    local longitudinalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)
                    autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. longitudinalEngineTags
                    autoNavigationAcceleration = autoNavigationAcceleration + longitudinalAcceleration
                    if (Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal) == 0 or -- we want to stop
                        Nav.axisCommandManager:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal) < - Nav.axisCommandManager:getTargetSpeedCurrentStep(axisCommandId.longitudinal) * 0.5) -- if the longitudinal velocity would need some braking
                    then
                        autoNavigationUseBrake = true
                    end

                end

                -- Lateral Translation
                local lateralStrafeEngineTags = 'thrust analog lateral'
                local lateralCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.lateral)
                if (lateralCommandType == axisCommandType.byThrottle) then
                    local lateralStrafeAcceleration =  Nav.axisCommandManager:composeAxisAccelerationFromThrottle(lateralStrafeEngineTags,axisCommandId.lateral)
                    Nav:setEngineForceCommand(lateralStrafeEngineTags, lateralStrafeAcceleration, keepCollinearity)
                elseif  (lateralCommandType == axisCommandType.byTargetSpeed) then
                    local lateralAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)
                    autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. lateralStrafeEngineTags
                    autoNavigationAcceleration = autoNavigationAcceleration + lateralAcceleration
                end

                -- Vertical Translation
                local verticalStrafeEngineTags = 'thrust analog vertical'
                local verticalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.vertical)
                if (verticalCommandType == axisCommandType.byThrottle) then
                    local verticalStrafeAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromThrottle(verticalStrafeEngineTags,axisCommandId.vertical)
                    Nav:setEngineForceCommand(verticalStrafeEngineTags, verticalStrafeAcceleration, keepCollinearity, 'airfoil', 'ground', '', tolerancePercentToSkipOtherPriorities)
                elseif  (verticalCommandType == axisCommandType.byTargetSpeed) then
                    local verticalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)
                    autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. verticalStrafeEngineTags
                    autoNavigationAcceleration = autoNavigationAcceleration + verticalAcceleration
                end

                -- Auto Navigation (Cruise Control)
                if (autoNavigationAcceleration:len() > constants.epsilon) then
                    if (brakeInput ~= 0 or autoNavigationUseBrake or math.abs(constructVelocityDir:dot(constructForward)) < 0.95)  -- if the velocity is not properly aligned with the forward
                    then
                        autoNavigationEngineTags = autoNavigationEngineTags .. ', brake'
                    end
                    Nav:setEngineForceCommand(autoNavigationEngineTags, autoNavigationAcceleration, dontKeepCollinearity, '', '', '', tolerancePercentToSkipOtherPriorities)
                end

                -- Rockets
                Nav:setBoosterCommand('rocket_engine')

        onUpdate:
            lua: |
              Nav:update()

              local worldVertical = vec3(core.getWorldVertical())
              local velocity = vec3(construct.getVelocity())

              local constructVelocity = vec3(construct.getWorldVelocity())
              local verticalSpeed = -worldVertical:dot(constructVelocity) * constants.m2kph

              local pitch = 0
              local roll = 0
              local yaw = -(math.deg(math.atan(velocity.y, velocity.x)) - 90)

              if worldVertical:len() > 0.01 and unit.getAtmosphereDensity() > 0.0 then
                -- Atmo
                local constrF = vec3(construct.getWorldOrientationForward())
                local constrR = vec3(construct.getWorldOrientationRight())

                roll = getRoll(worldVertical, constrF, constrR)
                pitch = getPitch(worldVertical, constrF, constrR)
              else
                -- Space
                pitch = getRelativePitch(velocity)
              end

              local tanks = ""
              for tank=1,atmofueltank_size do
                local top = (tank-1) * fuelTankDrawHeight + fuelTankTopOffset + 4
                local level = math.floor((atmoTanksCurrent[tank] / atmoTanksMax[tank]) * 100)
                tanks = tanks .. string.format(fuelTankTemplate, top, fuelTankDrawHeight-2, "atmoFuelLine", top, level, fuelTankDrawHeight-2)
              end

              for tank=1,rocketfueltank_size do
                local top = (tank+atmofueltank_size-1) * fuelTankDrawHeight + fuelTankTopOffset + 4
                local level = math.floor((rocketTanksCurrent[tank] / rocketTanksMax[tank]) * 100)
                tanks = tanks .. string.format(fuelTankTemplate, top, fuelTankDrawHeight-2, "rocketFuelLine", top, level, fuelTankDrawHeight-2)
              end

              for tank=1,spacefueltank_size do
                local top = (tank+atmofueltank_size+rocketfueltank_size-1) * fuelTankDrawHeight + fuelTankTopOffset + 4
                local level = math.floor((spaceTanksCurrent[tank] / spaceTanksMax[tank]) * 100)
                tanks = tanks .. string.format(fuelTankTemplate, top, fuelTankDrawHeight-2, "spaceFuelLine", top, level, fuelTankDrawHeight-2)
              end

              local throttleValue = math.floor(unit.getThrottle()) * 2
              local throttleDirection = 0
              if throttleValue < 0 then
                throttleValue = math.abs(throttleValue)
                throttleDirection = 200 - throttleValue
              end
              if throttleValue > 200 then throttleValue = 200 end

              local brakeStatus = "off"
              if brakeInput > 0 then brakeStatus = "on" end

              local constructMass = construct.getMass()/1000
              local constructMassUnits = "t"
              if constructMass >= 1000 then
                constructMassUnits = "kt"
                constructMass = constructMass / 1000
              end

              local targetAltitudeText = ""
              if holdMode == 3 then
                targetAltitudeText = string.format("%d m", targetAltitude)
              end

              local ccsMax = core.getMaxCoreStress()
              local ccsCurr = ccsMax - core.getCoreStress()
              local ccsPercent = ccsCurr/ccsMax * 100

              local aggSingularityHeight = "n/a"
              if antigrav ~= nil then
                aggSingularityHeight = string.format("%.1f m", antigrav.getBaseAltitude())
              end

              local holdModeIndicator = ""
              if holdMode == 2 then holdModeIndicator = "S" end
              if holdMode == 3 then holdModeIndicator = "A" end

              local warpInfo = ""
              if warpdrive ~= nil then
                --local driveData = json.decode(warpdrive.getData())
                --local dist =  --driveData.distance / 1000 / 200
                warpInfo = string.format(warpDriveTemplate, warpdrive.getDestination(), warpdrive.getDistance(), driveData.getAvailableWarpCells(), warpdrive.getStatus() and "ok" or "error")
              end

              local flightInfoALabel = "Vert:"
              local flightInfoBLabel = "Atmos:"
              local flightInfoCLabel = "AGG:"

              local flightInfoA = string.format("%.1f km/h", verticalSpeed)
              local flightInfoB = string.format("%.2f %s", atmosEdge, atmosEdgeUnits)
              local flightInfoC = aggSingularityHeight

              local flightAssistStatus = "off"
              if flightAssist then
                if not alignmentTarget then
                  flightAssistStatus = "error"
                else
                  flightAssistStatus = "on"

                  flightInfoALabel = "Braking in:"
                  flightInfoBLabel = ""
                  flightInfoCLabel = ""


                  local distanceToTarget = (alignmentTarget - vec3(construct.getWorldPosition())):len()
                  local distanceToBraking = distanceToTarget - brakingDistanceM - 300000
                  local secondsToTarget = distanceToBraking / constructVelocity:len()
                  local minutesToTarget = secondsToTarget / 60
                  secondsToTarget = math.floor(secondsToTarget - (math.floor(minutesToTarget)*60))
                  local hoursToTarget = minutesToTarget / 60
                  minutesToTarget = math.floor(minutesToTarget - (math.floor(hoursToTarget)*60))
                  hoursToTarget = math.floor(hoursToTarget)

                  flightInfoA = string.format("%02d:%02d:%02d", hoursToTarget, minutesToTarget, secondsToTarget)
                  flightInfoB = string.format("%.2f su", distanceToBraking / 200000)
                  flightInfoC = ""

                  if distanceToBraking <= 0 then
                    flightInfoA = "Now!"
                    flightInfoB = ""
                  end

                end

              end

              local guideline = ""
              if unit.getClosestPlanetInfluence() > 0.1 then
                guideline = guidelineTemplate
              end

              --keypadValueString = string.format("%d", keypadValue)
              vMouse.x = vMouse.x + system.getMouseDeltaX()
              vMouse.y = vMouse.y + system.getMouseDeltaY()
              if vMouse.x < 0 then vMouse.x = 0 end
              if vMouse.x > vMouse.maxX then vMouse.x = vMouse.maxX end
              if vMouse.y < 0 then vMouse.y = 0 end
              if vMouse.y > vMouse.maxY then vMouse.y = vMouse.maxY end

              local uiPanel = ""
              if vMouse.drawHandler then
                vMouse.drawHandler()
                uiPanel = vMouse.uiString
              end
              --local keypad = string.format(keypadTemplate, 1100, 600, keypadValueString, vMouse.x, vMouse.y)

              system.setScreen( string.format(hudTemplate,
                                                throttleDirection, throttleValue,
                                                tanks,
                                                brakeStatus,
                                                (holdMode>1 and "on" or "off"),
                                                flightAssistStatus,
                                                (gearExtended and "on" or "off"),
                                                holdModeIndicator,
                                                constructMass, constructMassUnits,
                                                brakingDistance, brakingDistanceUnit,
                                                pitch, roll, yaw,
                                                warpInfo,
                                                planetName, periapsis, apoapsis,
                                                flightInfoALabel, flightInfoBLabel, flightInfoCLabel,
                                                flightInfoA, flightInfoB, flightInfoC,
                                                damageReport.damaged, damageReport.destroyed, damageReport.damaged_elements, damageReport.destroyed_elements,
                                                ccsPercent, "", --shield
                                                targetAltitudeText,
                                                guideline,
                                                uiPanel --keypad
                                              )
                              )

              if atmo_radar_1 ~= nil then
                if atmo_radar_1.getOperationalState() == 1 then
                  atmo_radar_1.showWidget()
                else
                  atmo_radar_1.hideWidget()
                end
              end

              if space_radar_1 ~= nil then
                if space_radar_1.getOperationalState() == 1 then
                  space_radar_1.showWidget()
                else
                  space_radar_1.hideWidget()
                end
              end

        onActionStart:
            args: [gear]
            lua: |
                gearExtended = not gearExtended
                if gearExtended then
                    unit.deployLandingGears()
                    Nav.axisCommandManager:setTargetGroundAltitude(0)
                else
                    unit.retractLandingGears()
                    Nav.axisCommandManager:setTargetGroundAltitude(100)
                end

        onActionStart:
            args: [light]
            lua: |
                if unit.isAnyHeadlightSwitchedOn() == 1 then
                    unit.switchOffHeadlights()
                else
                    unit.switchOnHeadlights()
                end

        onActionStart:
            args: [forward]
            lua: pitchInput = -1
        onActionStop:
            args: [forward]
            lua: pitchInput = 0
        onActionStart:
            args: [backward]
            lua: pitchInput = 1
        onActionStop:
            args: [backward]
            lua: pitchInput = 0
        onActionStart:
            args: [left]
            lua: rollInput = -1
        onActionStop:
            args: [left]
            lua: rollInput = 0
        onActionStart:
            args: [right]
            lua: rollInput = 1
        onActionStop:
            args: [right]
            lua: rollInput = 0

        onActionStart:
            args: [straferight]
            lua: Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.lateral, 1.0)
        onActionStop:
            args: [straferight]
            lua: Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.lateral, -1.0)

        onActionStart:
            args: [strafeleft]
            lua: Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.lateral, -1.0)
        onActionStop:
            args: [strafeleft]
            lua: Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.lateral, 1.0)

        onActionStart:
            args: [up]
            lua: |
                Nav.axisCommandManager:deactivateGroundEngineAltitudeStabilization()
                Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.vertical, 1.0)
        onActionStop:
            args: [up]
            lua: |
                Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.vertical, -1.0)
                Nav.axisCommandManager:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)
        onActionStart:
            args: [down]
            lua: |
                Nav.axisCommandManager:deactivateGroundEngineAltitudeStabilization()
                Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.vertical, -1.0)
        onActionStop:
            args: [down]
            lua: |
                Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.vertical, 1.0)
                Nav.axisCommandManager:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)

        onActionStart:
            args: [groundaltitudeup]
            lua: Nav.axisCommandManager:updateTargetGroundAltitudeFromActionStart(1.0)

        onActionLoop:
            args: [groundaltitudeup]
            lua: Nav.axisCommandManager:updateTargetGroundAltitudeFromActionLoop(1.0)


        onActionStart:
            args: [groundaltitudedown]
            lua: Nav.axisCommandManager:updateTargetGroundAltitudeFromActionStart(-1.0)

        onActionLoop:
            args: [groundaltitudedown]
            lua: Nav.axisCommandManager:updateTargetGroundAltitudeFromActionLoop(-1.0)

        onActionStart:
            args: [yawright]
            lua: yawInput = -1
        onActionStop:
            args: [yawright]
            lua: yawInput = 0
        onActionStart:
            args: [yawleft]
            lua: yawInput = 1
        onActionStop:
            args: [yawleft]
            lua: yawInput = 0
        onActionStart:
            args: [brake]
            lua: |
                brakeInput = 1
                local longitudinalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)
                if (longitudinalCommandType == axisCommandType.byTargetSpeed) then
                    local targetSpeed = Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal)
                    if (math.abs(targetSpeed) > constants.epsilon) then
                        Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, - utils.sign(targetSpeed))
                    end
                end
        onActionStop:
            args: [brake]
            lua: |
              brakeInput = 0
              if brakeLock then
                brakeLock = false
              end

              --holdMode = 1
              pitchInput = 0
              rollInput = 0

        onActionLoop:
            args: [brake]
            lua: |
                local longitudinalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)
                if (longitudinalCommandType == axisCommandType.byTargetSpeed) then
                    local targetSpeed = Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal)
                    if (math.abs(targetSpeed) > constants.epsilon) then
                        Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal, - utils.sign(targetSpeed))
                    end
                end
        onActionStart:
            args: [booster]
            lua: Nav:toggleBoosters()
        onActionStart:
            args: [stopengines]
            lua: |
              if vMouse.drawHandler then
                if vMouse.clickHandler then
                  vMouse.clickHandler()
                end
              else
                Nav.axisCommandManager:resetCommand(axisCommandId.longitudinal)
              end
        onActionStart:
            args: [speedup]
            lua: Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, 5.0)
        onActionLoop:
            args: [speedup]
            lua: Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal, 0.2)
        onActionStart:
            args: [speeddown]
            lua: Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, -5.0)
        onActionLoop:
            args: [speeddown]
            lua: Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal, -0.2)
        onActionStart:
            args: [antigravity]
            lua: if antigrav ~= nil then showSingularityKeypad() end

        onActionStart:
            args: [option1]
            lua: |
                brakeLock = not brakeLock
                brakeInput = 0

        onActionStart:
            args: [option2]
            lua: |
                holdMode = holdMode + 1
                if holdMode > 3 then holdMode = 1 end
                if holdMode == 3 then targetAltitude = math.floor(core.getAltitude() / 100) * 100 end

                pitchInput = 0
                rollInput = 0
                collisionAvoidance = false
                flightAssist = false

        actionStart:
            args: [option3]
            lua: |
                --flightAssist = not flightAssist

        actionStop:
          args: [lshift]
          lua: |
              if vMouse.clickHandler then
                vMouse.clickHandler()
              end
