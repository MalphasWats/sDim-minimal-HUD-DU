name: sDimMinimalHUD

slots:
    core:
        class: CoreUnit
    antigrav:
        class: AntiGravityGeneratorUnit
    warpdrive:
        class: WarpDriveUnit
    atmofueltank:
        class: AtmoFuelContainer
        select: manual
    spacefueltank:
        class: SpaceFuelContainer
        select: manual
    rocketfueltank:
        class: RocketFuelContainer
        select: manual
    gyro:
        class: GyroUnit
    weapon:
        class: WeaponUnit
        select: manual
    atmo_radar:
        class: RadarPVPAtmospheric
        select: all
    space_radar:
        class: RadarPVPSpace
        select: manual
    databank:
        class: DataBankUnit
    screen:
        class: ScreenUnit
        select: manual
    forcefields:
        class: ManualSwitchUnit
        select: manual
    telemeter:
        class: TelemeterUnit
        select: manual
    emitter:
        class: EmitterUnit
        select: manual


handlers:
    library:
        start:
            lua: |

                damagedItemTemplate = [[<circle cx="%d" cy="%d" r="4" class="%s" /><text x="%d" y="%d" text-anchor="end">%s</text>]]

                function updateDMG()
                    local elementIDList = core.getElementIdList()

                    local elements = ""

                    local damaged_count = 0
                    local destroyed_count = 0

                    local damaged_elements = ""
                    local destroyed_elements = ""

                    for _,id in pairs(elementIDList) do
                        local max_hp = core.getElementMaxHitPointsById(id)
                        local curr_hp = core.getElementHitPointsById(id)
                        local name = core.getElementNameById(id)

                        if curr_hp == 0 then
                            destroyed_count = destroyed_count + 1
                            destroyed_elements = destroyed_elements .. string.format(damagedItemTemplate, 0, -(4+destroyed_count*14), "destroyed", -20, -(0+destroyed_count*14), name)
                        elseif curr_hp < max_hp then
                            damaged_count = damaged_count + 1
                            damaged_elements = damaged_elements .. string.format(damagedItemTemplate, -180, -(4+damaged_count*14), "damaged", -200, -(0+damaged_count*14), name)
                        end
                    end

                    damageReport.damaged = damaged_count
                    damageReport.destroyed = destroyed_count
                    damageReport.damaged_elements = damaged_elements
                    damageReport.destroyed_elements = destroyed_elements
                end
    unit:
        start:
            lua: |
                pitchInput = 0
                rollInput = 0
                yawInput = 0
                brakeInput = 0

                brakeLock = false

                targetAltitude = 0
                targetPitch = 0

                holdMode = 1
                autoAlign = false
                alignmentTarget = false
                collisionAvoidance = false

                boosting = false

                hudTemplate = [[
                <head>
                  <style>
                    body {margin: 0}
                    svg {position:absolute; top:0; left:0}
                    .outline {stroke:#b6dfed; stroke-width:2px; fill:#000000; fill-opacity:0.6;}

                    .line { fill:none; stroke:#b6dfed; stroke-width:3px; }
                    .mediumLine {fill:none; stroke:#b6dfed; stroke-width:2px; }
                    .thinLine { fill:none; stroke:#b6dfed; stroke-width:1px; }

                    .throttleMaxLine { fill:#ffffff66; stroke:#ffffff66; stroke-width:1px;}
                    .throttleLine { fill:#ff7e00; stroke:#ff7e00; stroke-width:1px;}

                    .fuelLine { fill:#aa0016; stroke:#aa001666; stroke-width:1px;}
                    .atmoFuelLine { fill:#4c8ba7; stroke:#4c8ba7; stroke-width:1px;}
                    .spaceFuelLine { fill:#fcba12; stroke:#fcba12; stroke-width:1px;}
                    .rocketFuelLine { fill:#323C73; stroke:#323C73; stroke-width:1px;}

                    .on {fill:#4c8ba7;}
                    .off {fill:none;}

                    text {fill:#b6dfed; stroke:none; font-size:100%%; font-family:sans-serif;}
                    .smallText { font-size:90%% }
                    .error {fill:#aa0016;}
                    .ok {fill:#00ff00;}
                    .damaged {fill:#ff7e00; stroke:#b6dfed; stroke-width:1px;}
                    .destroyed {fill:#aa0016; stroke:#b6dfed; stroke-width:1px;}
                  </style>
                </head>
                <body>

                <svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg" width="1920" height="1080">

                  <g class="outline">
                    <path style="stroke:none;" d="M 585,1080 589,1074 585,1063 615,1024 625,1026 645,998 645,988 1275,988 1275,998 1295,1026 1305,1024 1335,1063 1331,1074 1335,1080 Z" />
                    <path d="M 585,1080 589,1074 585,1063 615,1024 625,1026 645,998 645,988 577,992 457,1048 207,1060 195,1080" />

                    <path d="m 565,1070 6,-1" />
                    <path d="m 605,1012 4,8" />

                    <path d="M 1335,1080 1331,1074 1335,1063 1305,1024 1295,1026 1275,998 1275,988 1343,992 1463,1048 1713,1060 1725,1080" />
                    <path d="m 1355,1070 -6,-1" />
                    <path d="m 1315,1012 -4,8" />
                  </g>
                  <g class="thinLine" transform="translate(670, 1045)">
                    <text x="-10" y="20" text-anchor="end">Throttle</text>
                    <rect class="throttleMaxLine" x="0" y="11" width="200" height="10" />
                    <rect class="throttleLine" x="%d" y="11" width="%d" height="10" />

                    <line class="thinLine" x1="0" y1="2" x2="0" y2="10"/>
                    <line class="thinLine" x1="100" y1="2" x2="100" y2="10"/>
                    <line class="thinLine" x1="200" y1="2" x2="200" y2="10"/>

                    <line class="thinLine" x1="20" y1="5" x2="20" y2="10"/>
                    <line class="thinLine" x1="40" y1="5" x2="40" y2="10"/>
                    <line class="thinLine" x1="60" y1="5" x2="60" y2="10"/>
                    <line class="thinLine" x1="80" y1="5" x2="80" y2="10"/>

                    <line class="thinLine" x1="120" y1="5" x2="120" y2="10"/>
                    <line class="thinLine" x1="140" y1="5" x2="140" y2="10"/>
                    <line class="thinLine" x1="160" y1="5" x2="160" y2="10"/>
                    <line class="thinLine" x1="180" y1="5" x2="180" y2="10"/>
                  </g>

                  <g class="thinLine" transform="translate(930, 1045)">
                    <text x="-10" y="20" text-anchor="end">Fuel</text>
                    %s
                  </g>

                  <g class="thinLine smallText" transform="translate(1045, 1040)">
                    <text x="50" y="14" text-anchor="end">Brakes</text>
                    <text x="50" y="32" text-anchor="end">Gear</text>

                    <path class="%s" d="M 6,0 H 18 L 20,6 14,14 H 2 L 0,10 Z" transform="translate(80, 2) scale(-1, 1)"/>
                    <path class="%s" d="M 6,0 H 18 L 20,6 14,14 H 2 L 0,10 Z" transform="translate(80, 2)"/>
                    <path class="%s" d="M 6,0 H 18 L 20,6 14,14 H 2 L 0,10 Z" transform="translate(80, 32) scale(1, -1)"/>
                    <path class="%s" d="M 6,0 H 18 L 20,6 14,14 H 2 L 0,10 Z" transform="translate(80, 32) scale(-1, -1)"/>
                    <text style="font-size:9pt; fill:#000000" x="86" y="12" text-anchor="start">%s</text>
                    <text x="110" y="14" text-anchor="start">Hold</text>
                    <text x="110" y="32" text-anchor="start">F. Ass.</text>

                    <line class="thinLine" x1="165" y1="0" x2="165" y2="34"/>

                    <text x="220" y="12" text-anchor="end">Mass</text>
                    <text x="220" y="30" text-anchor="end">B. Dist.</text>

                    <text x="225" y="12" text-anchor="start">%.1f %s</text>
                    <text x="225" y="30" text-anchor="start">%.1f %s</text>
                  </g>

                  <g class="smallText" transform="translate(650, 990)">
                    <text x="40" y="14" text-anchor="end">Pitch:</text>
                    <text x="40" y="28" text-anchor="end">Roll:</text>
                    <text x="40" y="42" text-anchor="end">Yaw:</text>
                    <text x="85" y="14" text-anchor="end">%.1f°</text>
                    <text x="85" y="28" text-anchor="end">%.1f°</text>
                    <text x="85" y="42" text-anchor="end">%.1f°</text>

                    %s

                    <text x="400" y="14" text-anchor="end">Planet:</text>
                    <text x="400" y="28" text-anchor="end">Apoap:</text>
                    <text x="400" y="42" text-anchor="end">Periap:</text>
                    <text x="405" y="14" text-anchor="start">%s</text>
                    <text x="405" y="28" text-anchor="start">%.0f m</text>
                    <text x="405" y="42" text-anchor="start">%.0f m</text>

                    <text x="530" y="14" text-anchor="end">Vert:</text>
                    <text x="530" y="28" text-anchor="end">Atmos:</text>
                    <text x="530" y="42" text-anchor="end">AGG:</text>
                    <text x="535" y="14" text-anchor="start">%.1f km/h</text>
                    <text x="535" y="28" text-anchor="start">%.2f %s</text>
                    <text x="535" y="42" text-anchor="start">%s</text>
                  </g>

                  <g class="smallText" transform="translate(460, 1050)">
                    <text x="120" y="0" text-anchor="end">DMG: %d / %d</text>
                    %s %s
                  </g>

                  <g class="smallText" transform="translate(1380, 1050)">
                    <text x="0" y="0" text-anchor="end">CCS:</text>
                    <text x="5" y="0" text-anchor="start">%.0f %%</text>

                    %s
                  </g>

                  <text style="font-size:110%%" x="1460" y="80" text-anchor="end">%s</text>
                  %s
                </svg>

                </body>]]

                fuelTankTemplate = [[<rect class="fuelLine" x="0" y="%d" width="100" height="%d" />
                <rect class="%s" x="0" y="%d" width="%d" height="%d" />]]

                warpDriveTemplate = [[<text x="250" y="14" text-anchor="end">Warp:</text>
                <text x="250" y="28" text-anchor="end">Dist:</text>
                <text x="250" y="42" text-anchor="end">Cells:</text>
                <text x="255" y="14" text-anchor="start">%s</text>
                <text x="255" y="28" text-anchor="start">%.1f su</text>
                <text x="255" y="42" text-anchor="start">%s</text>

                <rect class="thinLine" x="315" y="22" width="18" height="18" />
                <rect class="%s" x="317" y="24" width="14" height="14" />]]

                shieldDataTemplate = [[<text x="0" y="14" text-anchor="end">Shield:</text>
                <text x="5" y="14" text-anchor="start">%.0f%%</text>

                <text x="60" y="14" text-anchor="start">AM: %.0f%%</text>
                <text x="125" y="14" text-anchor="start">EM: %.0f%%</text>
                <text x="190" y="14" text-anchor="start">KI: %.0f%%</text>
                <text x="245" y="14" text-anchor="start">TH: %.0f%%</text>]]

                guidelineTemplate = [[<line class="thinLine " x1="1764.5" y1="30" x2="1764.5" y2="280"/>]]

                -- Rocket to Space engine transition patch.
                local realGetMaxKP = core.getMaxKinematicsParametersAlongAxis
                core.getMaxKinematicsParametersAlongAxis = function (...)
                  local result = realGetMaxKP(...)
                  if result[1] < 1 then result[1] = result[3] end
                  if result[2] < 1 then result[2] = result[4] end
                  return result
                end

                function getPitch(gravityDirection, forward, right)
                    local horizontalForward = gravityDirection:cross(right):normalize_inplace()
                    local pitch = math.acos(utils.clamp(horizontalForward:dot(-forward), -1, 1)) * constants.rad2deg
                    if horizontalForward:cross(-forward):dot(right) < 0 then pitch = -pitch end
                    return pitch
                end

                function getRelativePitch(velocity)
                    local pitch = -math.deg(math.atan(velocity.y, velocity.z)) + 180
                    -- This is 0-360 where 0 is straight up
                    pitch = pitch - 90
                    -- So now 0 is straight, but we can now get angles up to 420
                    if pitch < 0 then
                       pitch = 360 + pitch
                    end
                    -- Now, if it's greater than 180, say 190, make it go to like -170
                    if pitch > 180 then
                       pitch = -180 + (pitch-180)
                    end
                    -- And it's backwards.
                    return -pitch
                end

                Nav = Navigator.new(system, core, unit)
                Nav.axisCommandManager:setupCustomTargetSpeedRanges(axisCommandId.longitudinal, {1000, 5000, 10000, 20000, 30000})

                unit.hide()
                system.showHelper(0)

                _autoconf.displayCategoryPanel(space_radar, space_radar_size, L_TEXT("ui_lua_widget_radar", "Radar"), "radar")

                --if antigrav ~= nil then antigrav.show() end
                --if warpdrive ~= nil then warpdrive.show() end

                _autoconf.displayCategoryPanel(weapon, weapon_size, L_TEXT("ui_lua_widget_weapon", "Weapons"), "weapon", true)


                -- freeze the player in he is remote controlling the construct
                if Nav.control.isRemoteControlled() == 1 then
                    system.freeze(1)
                end

                -- landing gear
                gearExtended = true
                local speed = vec3.new(core.getVelocity()):len() * constants.m2kph
                if speed > 100 then
                  gearExtended = false
                end

                if gearExtended then
                    Nav.control.extendLandingGears()
                    Nav.axisCommandManager:setTargetGroundAltitude(0)
                    if gyro ~= nil then
                      gyro.activate()
                      holdMode = 2
                    end
                else
                    Nav.control.retractLandingGears()
                    Nav.axisCommandManager:setTargetGroundAltitude(100)
                    if gyro ~= nil then
                      gyro.deactivate()
                      holdMode = 1
                    end
                end

                if forcefields_1 then
                  forcefields_1.activate()
                end

                -- Set R & T to 5% throttle, mousewheel still 10%
                Nav.axisCommandManager.axisCommands[axisCommandId.longitudinal].throttleAtomicStepValue  = 0.01
                Nav.axisCommandManager.axisCommands[axisCommandId.longitudinal].throttleMouseStepScale  =  10

                core.setDockingMode(2) -- Should dock with all owned

                atmoTanksMax = {}
                atmoTanksCurrent = {}

                rocketTanksMax = {}
                rocketTanksCurrent = {}

                spaceTanksMax = {}
                spaceTanksCurrent = {}

                fuelTankCount = atmofueltank_size + rocketfueltank_size + spacefueltank_size
                fuelTankDrawHeight = math.floor(22 / fuelTankCount)
                if fuelTankDrawHeight < 3 then fuelTankDrawHeight = 3 end
                local totalTankDrawHeight = fuelTankDrawHeight * fuelTankCount
                fuelTankTopOffset = 22 - totalTankDrawHeight
                if fuelTankTopOffset < 0 then fuelTankTopOffset = 0 end

                for tank=1,atmofueltank_size do
                  atmoTanksMax[tank] = math.floor(atmofueltank[tank].getMaxVolume())
                  atmoTanksCurrent[tank] = math.floor(atmofueltank[tank].getItemsVolume())
                end

                for tank=1,rocketfueltank_size do
                  rocketTanksMax[tank] = math.floor(rocketfueltank[tank].getMaxVolume())
                  rocketTanksCurrent[tank] = math.floor(rocketfueltank[tank].getItemsVolume())
                end

                for tank=1,spacefueltank_size do
                  spaceTanksMax[tank] = math.floor(spacefueltank[tank].getMaxVolume())
                  spaceTanksCurrent[tank] = math.floor(spacefueltank[tank].getItemsVolume())
                end

                unit.setTimer("updateTanks", 1) -- one second

                brakingDistance = 0
                brakingDistanceUnit = "km"
                function calculateBrakingDistance()
                  local speed = vec3.new(core.getVelocity()):len()
                  local mass = core.getConstructMass()
                  local maxBrakingForce = json.decode(unit.getData()).maxBrake
                  if not maxBrakingForce then
                    brakingDistance = 0
                    brakingDistanceUnit = "km"
                    return
                  end

                  local c = (30000*1000)/3600
                  local cSq = c*c
                  local totA = -maxBrakingForce * (1 / mass)

                  local k1 = c * math.asin( speed / c)
                  local k2 = cSq * math.cos(k1 / c) / totA
                  local t = -k1 / totA
                  local d = k2 - cSq * math.cos( (totA*t + k1) / c ) / totA
                  local d_su = d / 200000

                  if d_su < 0.5 then
                    brakingDistance = d / 1000
                    brakingDistanceUnit = "km"
                  else
                    brakingDistance = d_su
                    brakingDistanceUnit = "su"
                  end

                end

                calculateBrakingDistance()
                unit.setTimer("updateBraking", 1) -- 30 seconds

                periapsis = 0
                apoapsis = 0
                planetName = "None"
                planetAlt = 0
                atmosEdge = 0
                atmosEdgeUnits = "m"

                function getOrbitalParameters()

                  local position = core.getConstructWorldPos()
                  local pos = vec3(position)
                  local planet

                  local minDistance2
                  for _, params in pairs(atlas[0]) do
                      local bcenter = {
                          x = params.center[1],
                          y = params.center[2],
                          z = params.center[3]
                      }
                      local distance2 = (bcenter - pos):len2()
                      if (not planet or distance2 < minDistance2) and params.name[1] ~= "Space" then -- Never return space.
                          planet = params
                          minDistance2 = distance2
                      end
                  end

                  planetName = planet.name[1]

                  local velocity = core.getWorldVelocity()
                  local v = vec3(velocity)

                  local center = vec3(planet.center)

                  planetAlt = (pos - center):len() - planet.radius - planet.surfaceAverageAltitude
                  atmosEdge = (pos - center):len() - planet.radius - planet.atmosphereThickness
                  if atmosEdge > 10000 then
                    atmosEdge = atmosEdge / 1000
                    atmosEdgeUnits = "km"
                    if atmosEdge > 100 then
                      atmosEdge = atmosEdge / 200
                      atmosEdgeUnits = "su"
                    end
                  end


                  local r = pos - center
                  local v2 = v:len2()
                  local d = r:len()
                  local mu = planet.GM
                  local e = ((v2 - mu / d) * r - r:dot(v) * v) / mu
                  local a = mu / (2 * mu / d - v2)
                  local ecc = e:len()

                  local pd = a * (1 - ecc)
                  local ad = a * (1 + ecc)

                  periapsis = pd - planet.radius
                  apoapsis = ad - planet.radius
                  if periapsis < 0 then periapsis = 0 end
                  if apoapsis < 0 then apoapsis = 0 end
                end

                getOrbitalParameters()
                unit.setTimer("updateOrbitParams", 1) -- 1 seconds

                damageReport = {damaged = 0, destroyed = 0, damaged_elements="", destroyed_elements=""}
                updateDMG()
                unit.setTimer("updateDMGReport",  10)
        stop:
            lua: |
                _autoconf.hideCategoryPanels()
                if antigrav ~= nil then antigrav.hide() end
                if warpdrive ~= nil then warpdrive.hide() end
                if gyro ~= nil then gyro.hide() end
                core.hide()

                --if gearExtended then
                    if forcefields_1 then
                      forcefields_1.deactivate()
                    end
                --else
                --    if forcefields_1 then
                --      forcefields_1.activate()
                --    end
                --end

        tick:
          args: ["updateTanks"]
          lua: |
            for tank=1,atmofueltank_size do
              atmoTanksCurrent[tank] = math.floor(atmofueltank[tank].getItemsVolume())
            end

            for tank=1,rocketfueltank_size do
              rocketTanksCurrent[tank] = math.floor(rocketfueltank[tank].getItemsVolume())
            end

            for tank=1,spacefueltank_size do
              spaceTanksCurrent[tank] = math.floor(spacefueltank[tank].getItemsVolume())
            end

        tick:
          args: ["updateBraking"]
          lua: |
            calculateBrakingDistance()

        tick:
          args: ["updateOrbitParams"]
          lua: |
            getOrbitalParameters()

        tick:
          args: ["updateDMGReport"]
          lua: |
            updateDMG()

    system:
        start:
            lua: |
                atlas = require('atlas')
                system.setScreen('HUD Error')
                screenOn = 1
                system.showScreen(screenOn)

        flush:
            lua: |
                -- constants: use 'myvar = defaultValue --export: description' to expose the variable in context menu

                local pitchSpeedFactor = 0.8 --export: This factor will increase/decrease the player input along the pitch axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01
                local yawSpeedFactor =  3 --export: This factor will increase/decrease the player input along the yaw axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01
                local rollSpeedFactor = 1.5 --export: This factor will increase/decrease the player input along the roll axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01

                local brakeSpeedFactor = 10 --export: When braking, this factor will increase the brake force by brakeSpeedFactor * velocity<br>Valid values: Superior or equal to 0.01
                local brakeFlatFactor = 10 --export: When braking, this factor will increase the brake force by a flat brakeFlatFactor * velocity direction><br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01

                local torqueFactor = 2 -- Force factor applied to reach rotationSpeed<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01

                -- validate params
                pitchSpeedFactor = math.max(pitchSpeedFactor, 0.01)
                yawSpeedFactor = math.max(yawSpeedFactor, 0.01)
                rollSpeedFactor = math.max(rollSpeedFactor, 0.01)
                torqueFactor = math.max(torqueFactor, 0.01)
                brakeSpeedFactor = math.max(brakeSpeedFactor, 0.01)
                brakeFlatFactor = math.max(brakeFlatFactor, 0.01)

                -- Axis
                local worldVertical = vec3(core.getWorldVertical()) -- along gravity
                local constructUp = vec3(core.getConstructWorldOrientationUp())
                local constructForward = vec3(core.getConstructWorldOrientationForward())
                local constructRight = vec3(core.getConstructWorldOrientationRight())
                local constructVelocity = vec3(core.getWorldVelocity())
                local constructVelocityDir = vec3(core.getWorldVelocity()):normalize()
                --local currentRollDeg = getRoll(worldVertical, constructForward, constructRight)
                --local currentRollDegAbs = math.abs(currentRollDeg)
                --local currentRollDegSign = utils.sign(currentRollDeg)

                if brakeLock then
                  brakeInput = 1
                end

                if telemeter_1 ~= nil and (brakeInput < 1 or collisionAvoidance) then
                  local speed = vec3.new(core.getVelocity()):len() * constants.m2kph
                  local obstacleDistance = telemeter_1.getDistance()

                  if obstacleDistance > -1 then
                      if speed > 250 then
                          brakeInput = 1
                          collisionAvoidance = true
                      else
                          brakeInput = 0
                          collisionAvoidance = false
                      end
                  else
                      brakeInput = 0
                      collisionAvoidance = false
                  end
                end

                if holdMode>1 and unit.getAtmosphereDensity() > 0 then

                  local roll = getRoll(worldVertical, constructForward, constructRight)
                  local pitch = getPitch(worldVertical, constructForward, constructRight)
                  local targetRoll = 0

                  if holdMode == 3 then
                    local altitude = core.getAltitude()
                    local velMag = vec3(constructVelocity):len()

                    local altDiff = targetAltitude - altitude
                    local MaxPitch = 20

                    local minmax = 500 + velMag
                    targetPitch = (utils.smoothstep(altDiff, -minmax, minmax) - 0.5)*2*MaxPitch
                  end

                  if (rollPID == nil) then
                      rollPID = pid.new(6 * 0.01, 0, 6 * 0.02)
                  end
                  rollPID:inject(targetRoll - roll)
                  rollInput = rollPID:get()

                  if (pitchPID == nil) then
                    pitchPID = pid.new(8 * 0.01, 0, 8 * 0.01)
                  end
                  pitchPID:inject(targetPitch - pitch)
                  pitchInput = pitchPID:get()
                end

                local targetAngularVelocity
                -- final inputs
                local finalPitchInput = pitchInput + system.getControlDeviceForwardInput()
                local finalRollInput = rollInput + system.getControlDeviceYawInput()
                local finalYawInput = yawInput - system.getControlDeviceLeftRightInput()
                local finalBrakeInput = brakeInput

                if autoAlign then
                  local p=vec3(core.getConstructWorldPos())
                  local v=(alignmentTarget - p):normalize()
                  --targetAngularVelocity = (-v:cross(constructForward)) * constructRight  * constructForward * constructUp
                  targetAngularVelocity = (-v:cross(constructForward)) + finalPitchInput * pitchSpeedFactor * constructRight + finalRollInput * rollSpeedFactor * constructForward + finalYawInput * yawSpeedFactor * constructUp
                else
                  targetAngularVelocity = finalPitchInput * pitchSpeedFactor * constructRight
                                                  + finalRollInput * rollSpeedFactor * constructForward
                                                  + finalYawInput * yawSpeedFactor * constructUp
                end

                -- Rotation
                local constructAngularVelocity = vec3(core.getWorldAngularVelocity())


                -- Engine commands
                local keepCollinearity = 1 -- for easier reading
                local dontKeepCollinearity = 0 -- for easier reading
                local tolerancePercentToSkipOtherPriorities = 1 -- if we are within this tolerance (in%), we don't go to the next priorities

                -- Rotation
                local angularAcceleration = torqueFactor * (targetAngularVelocity - constructAngularVelocity)
                local airAcceleration = vec3(core.getWorldAirFrictionAngularAcceleration())
                angularAcceleration = angularAcceleration - airAcceleration -- Try to compensate air friction
                Nav:setEngineTorqueCommand('torque', angularAcceleration, keepCollinearity, 'airfoil', '', '', tolerancePercentToSkipOtherPriorities)

                -- Brakes
                local brakeAcceleration = -finalBrakeInput * (brakeSpeedFactor * constructVelocity + brakeFlatFactor * constructVelocityDir)
                Nav:setEngineForceCommand('brake', brakeAcceleration)

                -- AutoNavigation regroups all the axis command by 'TargetSpeed'
                local autoNavigationEngineTags = ''
                local autoNavigationAcceleration = vec3()
                local autoNavigationUseBrake = false

                -- Longitudinal Translation
                local longitudinalEngineTags = 'thrust analog longitudinal'
                local longitudinalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)
                if (longitudinalCommandType == axisCommandType.byThrottle) then
                    local longitudinalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromThrottle(longitudinalEngineTags,axisCommandId.longitudinal)
                    Nav:setEngineForceCommand(longitudinalEngineTags, longitudinalAcceleration, keepCollinearity)
                elseif  (longitudinalCommandType == axisCommandType.byTargetSpeed) then
                    local longitudinalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)
                    autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. longitudinalEngineTags
                    autoNavigationAcceleration = autoNavigationAcceleration + longitudinalAcceleration
                    if (Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal) == 0 or -- we want to stop
                        Nav.axisCommandManager:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal) < - Nav.axisCommandManager:getTargetSpeedCurrentStep(axisCommandId.longitudinal) * 0.5) -- if the longitudinal velocity would need some braking
                    then
                        autoNavigationUseBrake = true
                    end

                end

                -- Lateral Translation
                local lateralStrafeEngineTags = 'thrust analog lateral'
                local lateralCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.lateral)
                if (lateralCommandType == axisCommandType.byThrottle) then
                    local lateralStrafeAcceleration =  Nav.axisCommandManager:composeAxisAccelerationFromThrottle(lateralStrafeEngineTags,axisCommandId.lateral)
                    Nav:setEngineForceCommand(lateralStrafeEngineTags, lateralStrafeAcceleration, keepCollinearity)
                elseif  (lateralCommandType == axisCommandType.byTargetSpeed) then
                    local lateralAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)
                    autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. lateralStrafeEngineTags
                    autoNavigationAcceleration = autoNavigationAcceleration + lateralAcceleration
                end

                -- Vertical Translation
                local verticalStrafeEngineTags = 'thrust analog vertical'
                local verticalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.vertical)
                if (verticalCommandType == axisCommandType.byThrottle) then
                    local verticalStrafeAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromThrottle(verticalStrafeEngineTags,axisCommandId.vertical)
                    Nav:setEngineForceCommand(verticalStrafeEngineTags, verticalStrafeAcceleration, keepCollinearity, 'airfoil', 'ground', '', tolerancePercentToSkipOtherPriorities)
                elseif  (verticalCommandType == axisCommandType.byTargetSpeed) then
                    local verticalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)
                    autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. verticalStrafeEngineTags
                    autoNavigationAcceleration = autoNavigationAcceleration + verticalAcceleration
                end

                -- Auto Navigation (Cruise Control)
                if (autoNavigationAcceleration:len() > constants.epsilon) then
                    if (brakeInput ~= 0 or autoNavigationUseBrake or math.abs(constructVelocityDir:dot(constructForward)) < 0.95)  -- if the velocity is not properly aligned with the forward
                    then
                        autoNavigationEngineTags = autoNavigationEngineTags .. ', brake'
                    end
                    Nav:setEngineForceCommand(autoNavigationEngineTags, autoNavigationAcceleration, dontKeepCollinearity, '', '', '', tolerancePercentToSkipOtherPriorities)
                end

                Nav:setBoosterCommand('rocket_engine')

        update:
            lua: |
              Nav:update()
              local worldVertical = vec3(core.getWorldVertical())
              local velocity = vec3(core.getVelocity())

              local constructVelocity = vec3(core.getWorldVelocity())
              local verticalSpeed = -worldVertical:dot(constructVelocity) * constants.m2kph

              local pitch = 0
              local roll = 0
              local yaw = -(math.deg(math.atan(velocity.y, velocity.x)) - 90)

              if worldVertical:len() > 0.01 and unit.getAtmosphereDensity() > 0.0 then
                -- Atmo
                local constrF = vec3(core.getConstructWorldOrientationForward())
                local constrR = vec3(core.getConstructWorldOrientationRight())

                roll = getRoll(worldVertical, constrF, constrR)
                pitch = getPitch(worldVertical, constrF, constrR)
              else
                -- Space
                pitch = getRelativePitch(velocity)
              end

              local tanks = ""
              for tank=1,atmofueltank_size do
                local top = (tank-1) * fuelTankDrawHeight + fuelTankTopOffset + 4
                local level = math.floor((atmoTanksCurrent[tank] / atmoTanksMax[tank]) * 100)
                tanks = tanks .. string.format(fuelTankTemplate, top, fuelTankDrawHeight-2, "atmoFuelLine", top, level, fuelTankDrawHeight-2)
              end

              for tank=1,rocketfueltank_size do
                local top = (tank+atmofueltank_size-1) * fuelTankDrawHeight + fuelTankTopOffset + 4
                local level = math.floor((rocketTanksCurrent[tank] / rocketTanksMax[tank]) * 100)
                tanks = tanks .. string.format(fuelTankTemplate, top, fuelTankDrawHeight-2, "rocketFuelLine", top, level, fuelTankDrawHeight-2)
              end

              for tank=1,spacefueltank_size do
                local top = (tank+atmofueltank_size+rocketfueltank_size-1) * fuelTankDrawHeight + fuelTankTopOffset + 4
                local level = math.floor((spaceTanksCurrent[tank] / spaceTanksMax[tank]) * 100)
                tanks = tanks .. string.format(fuelTankTemplate, top, fuelTankDrawHeight-2, "spaceFuelLine", top, level, fuelTankDrawHeight-2)
              end

              local throttleValue = math.floor(unit.getThrottle()) * 2
              local throttleDirection = 0
              if throttleValue < 0 then
                throttleValue = math.abs(throttleValue)
                throttleDirection = 200 - throttleValue
              end
              if throttleValue > 200 then throttleValue = 200 end

              local brakeStatus = "off"
              if brakeInput > 0 then brakeStatus = "on" end

              local constructMass = core.getConstructMass()/1000
              local constructMassUnits = "t"
              if constructMass >= 1000 then
                constructMassUnits = "kt"
                constructMass = constructMass / 1000
              end

              local targetAltitudeText = ""
              if holdMode == 3 then
                targetAltitudeText = string.format("%d m", targetAltitude)
              end

              local ccsMax = core.getMaxCoreStress()
              local ccsCurr = ccsMax - core.getCoreStress()
              local ccsPercent = ccsCurr/ccsMax * 100

              local aggSingularityHeight = "n/a"
              if antigrav ~= nil then
                aggSingularityHeight = string.format("%.1f m", antigrav.getBaseAltitude())
              end

              local holdModeIndicator = ""
              if holdMode == 2 then holdModeIndicator = "S" end
              if holdMode == 3 then holdModeIndicator = "A" end

              local warpInfo = ""
              if warpdrive ~= nil then
                local driveData = json.decode(warpdrive.getData())
                local dist = driveData.distance / 1000 / 200
                warpInfo = string.format(warpDriveTemplate, driveData.destination, dist, driveData.cellCount, driveData.enableButton and "ok" or "error")
              end

              local flightAssist = "off"
              if autoAlign then
                if not alignmentTarget then
                  flightAssist = "error"
                else
                  flightAssist = "on"
                end
              end

              local guideline = ""
              if unit.getClosestPlanetInfluence() > 0.1 then
                guideline = guidelineTemplate
              end

              system.setScreen( string.format(hudTemplate,
                                                throttleDirection, throttleValue,
                                                tanks,
                                                brakeStatus,
                                                (holdMode>1 and "on" or "off"),
                                                flightAssist,
                                                (gearExtended and "on" or "off"),
                                                holdModeIndicator,
                                                constructMass, constructMassUnits,
                                                brakingDistance, brakingDistanceUnit,
                                                pitch, roll, yaw,
                                                warpInfo,
                                                planetName, periapsis, apoapsis,
                                                verticalSpeed, atmosEdge, atmosEdgeUnits, aggSingularityHeight,
                                                damageReport.damaged, damageReport.destroyed, damageReport.damaged_elements, damageReport.destroyed_elements,
                                                ccsPercent, "", --shield
                                                targetAltitudeText,
                                                guideline
                                              )
                              )

        actionStart:
            args: [gear]
            lua: |
                gearExtended = not gearExtended
                if gearExtended then
                    Nav.control.extendLandingGears()
                    Nav.axisCommandManager:setTargetGroundAltitude(0)
                    --boostersOn = false
                    if gyro ~= nil then
                      gyro.activate()
                      holdMode = 2
                    end
                else
                    Nav.control.retractLandingGears()
                    Nav.axisCommandManager:setTargetGroundAltitude(100)
                    brakeLock = false
                    brakeInput = 0

                    if gyro ~= nil then
                      gyro.deactivate()
                      holdMode = 1
                    end
                end

        actionStart:
            args: [light]
            lua: |
                if Nav.control.isAnyHeadlightSwitchedOn() == 1 then
                    Nav.control.switchOffHeadlights()
                else
                    Nav.control.switchOnHeadlights()
                end

        actionStart:
            args: [forward]
            lua: pitchInput = -1 --pitchInput - 1
        actionStop:
            args: [forward]
            lua: pitchInput = 0 --pitchInput + 1
        actionStart:
            args: [backward]
            lua: pitchInput = 1 --pitchInput + 1
        actionStop:
            args: [backward]
            lua: pitchInput = 0 --pitchInput - 1
        actionStart:
            args: [left]
            lua: rollInput = -1 --rollInput - 1
        actionStop:
            args: [left]
            lua: rollInput = 0 --rollInput + 1
        actionStart:
            args: [right]
            lua: rollInput = 1 --rollInput + 1
        actionStop:
            args: [right]
            lua: rollInput = 0 --rollInput - 1
        actionStart:
            args: [yawright]
            lua: yawInput = -1 --yawInput - 1
        actionStop:
            args: [yawright]
            lua: yawInput = 0 --yawInput + 1
        actionStart:
            args: [yawleft]
            lua: yawInput = 1 --yawInput + 1
        actionStop:
            args: [yawleft]
            lua: yawInput = 0 --yawInput - 1

        actionStart:
            args: [straferight]
            lua: Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.lateral, 1.0)
        actionStop:
            args: [straferight]
            lua: Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.lateral, -1.0)

        actionStart:
            args: [strafeleft]
            lua: Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.lateral, -1.0)
        actionStop:
            args: [strafeleft]
            lua: Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.lateral, 1.0)

        actionStart:
            args: [up]
            lua: |
                Nav.axisCommandManager:deactivateGroundEngineAltitudeStabilization()
                Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.vertical, 1.0)
        actionStop:
            args: [up]
            lua: |
                Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.vertical, -1.0)
                Nav.axisCommandManager:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)
        actionStart:
            args: [down]
            lua: |
                Nav.axisCommandManager:deactivateGroundEngineAltitudeStabilization()
                Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.vertical, -1.0)
        actionStop:
            args: [down]
            lua: |
                Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.vertical, 1.0)
                Nav.axisCommandManager:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)

        actionStart:
            args: [groundaltitudeup]
            lua: Nav.axisCommandManager:updateTargetGroundAltitudeFromActionStart(1.0)

        actionLoop:
            args: [groundaltitudeup]
            lua: Nav.axisCommandManager:updateTargetGroundAltitudeFromActionLoop(1.0)


        actionStart:
            args: [groundaltitudedown]
            lua: Nav.axisCommandManager:updateTargetGroundAltitudeFromActionStart(-1.0)

        actionLoop:
            args: [groundaltitudedown]
            lua: Nav.axisCommandManager:updateTargetGroundAltitudeFromActionLoop(-1.0)

        actionStart:
            args: [brake]
            lua: |
                brakeInput = 1 -- brakeInput + 1
                local longitudinalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)
                if (longitudinalCommandType == axisCommandType.byTargetSpeed) then
                    local targetSpeed = Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal)
                    if (math.abs(targetSpeed) > constants.epsilon) then
                        Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, - utils.sign(targetSpeed))
                    end
                end

        actionStop:
            args: [brake]
            lua: |
                brakeInput = 0
                if brakeLock then
                  brakeLock = false
                end

                --holdMode = 1
                pitchInput = 0
                rollInput = 0

        actionLoop:
            args: [brake]
            lua: |
                local longitudinalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)
                if (longitudinalCommandType == axisCommandType.byTargetSpeed) then
                    local targetSpeed = Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal)
                    if (math.abs(targetSpeed) > constants.epsilon) then
                        Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal, - utils.sign(targetSpeed))
                    end
                end

        actionStart:
            args: [booster]
            lua: |
                  Nav:toggleBoosters()
                  boosting = not boosting

        actionStart:
              args: [stopengines]
              lua: Nav.axisCommandManager:resetCommand(axisCommandId.longitudinal)
        actionStart:
            args: [speedup]
            lua: Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, 5.0)
        actionLoop:
            args: [speedup]
            lua: Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal, 0.2)
        actionStart:
            args: [speeddown]
            lua: Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, -5.0)
        actionLoop:
            args: [speeddown]
            lua: Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal, -0.2)

        actionStart:
            args: [antigravity]
            lua: if antigrav ~= nil then antigrav.toggle() end
        actionStart:
            args: [warp]
            lua: if warpdrive ~= nil then warpdrive.activateWarp() end

        actionStart:
            args: [option1]
            lua: |
                brakeLock = not brakeLock
                brakeInput = 0

        actionStart:
            args: [option2]
            lua: |
                holdMode = holdMode + 1
                if holdMode > 3 then holdMode = 1 end
                if holdMode == 3 then targetAltitude = math.floor(core.getAltitude() / 100) * 100 end

                pitchInput = 0
                rollInput = 0
                collisionAvoidance = false
                autoAlign = false

        actionStart:
            args: [option3]
            lua: |
                autoAlign = not autoAlign

        actionStart:
            args: [option9]
            lua: |
                emitter_1.send("SiloDoors", "open")

        inputText(text):
              lua: |
                local cmd = text
                local sp = string.find(cmd, " ")
                local param = nil

                if sp ~= nil then
                  param = string.sub(cmd, sp+1)
                  cmd = string.sub(cmd, 0, sp-1)
                end

                if cmd ~= nil then
                  if cmd == "/alignTo" and param ~= nil then
                      local num  = ' *([+-]?%d+%.?%d*e?[+-]?%d*)'
                      local posPattern = '::pos{' .. num .. ',' .. num .. ',' ..  num .. ',' .. num ..  ',' .. num .. '}'
                      local systemId, id, latitude, longitude, altitude = string.match(param, posPattern)

                      if (systemId == "0" and id == "0") then
                          alignmentTarget = vec3(tonumber(latitude), tonumber(longitude), tonumber(altitude))
                          system.setWaypoint(param)
                      else
                          longitude = math.rad(longitude)
                          latitude = math.rad(latitude)
                          local planet = atlas[tonumber(systemId)][tonumber(id)]
                          system.print(planet.name[1])
                          local xproj = math.cos(latitude);
                          local planetxyz = vec3(xproj*math.cos(longitude),
                              xproj*math.sin(longitude),
                              math.sin(latitude));
                          local position = vec3(planet.center) + (planet.radius + altitude) * planetxyz
                          local waypoint = '::pos{0, 0, ' .. position.x .. ', ' .. position.y .. ', ' .. position.z .. '}'
                          alignmentTarget = vec3(tonumber(position.x), tonumber(position.y), tonumber(position.z))
                          system.setWaypoint(waypoint)
                      end
                  end
                end
